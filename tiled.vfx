private

0 value tile#  0 value nextGID  0 value tsSrc  0 value jtilesets
0 value tmjSrc  0 value tsjSrc  0 value zname  0 value layerSrc
0 value tmjPath$

: gids, ( jlayer - )
    "data" j@ [: j>int , ;] jeach-fast ;

: *array-from-jlayer ( jlayer - array )
    >r cell array{ r> gids, array} ;

: @dims ( layerSrc - w h )
    dup "width" @j swap "height" @j ;

: @xy ( jobj - x. y. )
    >r r@ "x" p@j r@ "width" p@j 2 / +
       r@ "y" p@j r> "height" p@j 2 / - ;

: @actor ( jobj - actor|0 )
    {: obj :}
    obj "type" ['] s@j catch if
        2drop
        ." No 'type' property found in JSON object, skipping..." cr
        0 exit
    then
    f" %%%s" sfind if
        execute make { obj @xy x 2!
        me }
    else
        ( $ ) f" Class %$ not found, skipping..." type cr
        0
    then ;

: stage-allocator ( n - a ior )
    drop stage-slot 0 ;

: on-stage
    ['] stage-allocator allocator! ;

: fix-gids ( ofs array - )
    [: udup +! ;] swap eacha drop ;

public

trait: %dimensional
    prop w :int
    prop h :int

    :: dims ( - w h )
        w 2@ ;
trait;

class: %tilemap
    is-a %drawable
    is-a %dimensional
    prop ta :ref %array
    prop ts :ref %tileset
    \ 32 nprop name :cstring

    :: draw ( - )
        ts @ >baseid @ pile!
        ta @ 0 nth w 2@ drawbg ;
class;

class: %jsonfile
    %asset derive
    is-a %autoload
    is-a %loadable
    prop json :addr

    : _load-json ( - )
        me @data parse-json json ! ;

    :: on-startup ( - )
        ." Loading JSON file " me .name cr
        _load-json ;

class;

: jsonfile ( <path> - )
    bl parse 2dup -path %jsonfile asset { embed _load-json }
    does> dup >srcpath$ to tmjPath$ >json @ ;

: jnamed? ( jobj zname - flag ) swap "name" z@j z$= ;

: find-layer ( tmj zlayer-name - jlayer )
    to zname to tmjSrc
    0 tmjSrc "layers" j@ [: j@ dup zname jnamed? if nip else drop then ;] jeach
    ?dup 0= if -1 zname f" Layer '%z' not found" .abort then ;

: load-to-stage ( zlayer-name - )
    t{ on-stage tmjSrc swap find-layer "objects" j@ [: j@ @actor drop ;] jeach t} ;

: ?tileset ( jtileset - )
    to tsSrc
    tsSrc "source" s@j '.' ending s" tsx" s= abort" Only .TSJ tilesets are supported."
    tsSrc "source" s@j -path sfind nip ?exit  \ tileset is already loaded

    tsSrc "source" s@j 
    tmjPath$ count '\' <scan
    f" jsonfile %s\%s" .evaluate  \ load the .TSJ file
    lastbody >json @ to tsjSrc
    tsjSrc "image" s@j -path sfind nip 0= if
        tsjSrc "image" s@j 
        tmjPath$ count '\' <scan
        f" bitmap %s\%s" .evaluate  \ load the bitmap
    then

    tsSrc "source" s@j -path -ext
    tsjSrc "tileheight" @j
    tsjSrc "tilewidth" @j
    tsjSrc "image" s@j -path
    f" %s %n %n tileset-from %s.ts" .evaluate
;

: load-tmj-tilesets ( tmj - )
    "tilesets" j@ [: j@ ?tileset ;] jeach ;

: find-first-nonzero ( array - n )
    0 [: ?dup if nip enough then ;] rot each ;

: find-tileset-ref ( tile# - jtileset|0 )
    to tile#
    tmjSrc load-tmj-tilesets
    tmjSrc "tilesets" j@ to jtilesets
    0
    jtilesets [:
        2dup j@ to tsSrc

        \ get nextGID
        1 + dup jtilesets jlen < if j@ "firstgid" @j else 2drop 65536 then to nextGID

        \ if tile# within the range, get the tileset object
        tile#` tsSrc "firstgid" @j` nextGID` within? if drop tsSrc .s enough then
    ;] jeach ;

: *tilemap-from ( tmj zlayername - tilemap )
    to zname to tmjSrc
    %tilemap dmake {
        tmjSrc load-tmj-tilesets
        tmjSrc zname find-layer to layerSrc
        layerSrc @dims w 2!                           \ get dimensions
        layerSrc *array-from-jlayer ta !              \ get tiles (GID's)
        ta @ find-first-nonzero find-tileset-ref ( jtileset )
        ?dup -exit 
        dup 
        "source" s@j -ext f" %s.ts" evaluate ts !
        "firstgid" @j negate  \ ts @ >baseid @ +
        ta @ fix-gids 
    me } ;

: tilemap-from ( tileset tmj zname <name> - )
    create *tilemap-from drop ;

\ : get-metadata ( tsj - )
\     ;
